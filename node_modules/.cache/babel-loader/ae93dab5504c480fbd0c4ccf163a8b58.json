{"ast":null,"code":"import { isConstantNode, isParenthesisNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { createSimplifyCore } from './simplify/simplifyCore.js';\nimport { createSimplifyConstant } from './simplify/simplifyConstant.js';\nimport { createResolve } from './simplify/resolve.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    parse,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    isZero,\n    equal,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var simplifyConstant = createSimplifyConstant({\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  });\n  var simplifyCore = createSimplifyCore({\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode\n  });\n  var resolve = createResolve({\n    parse,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode\n  });\n  var {\n    isCommutative,\n    isAssociative,\n    flatten,\n    unflattenr,\n    unflattenl,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n        and any changes to it, along with the rule responsible, to console\n   *  - `exactFractions` (true): whether to try to convert all constants to\n        exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n        be expressed as fractions only when both numerator and denominator\n        are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, createEmptyMap(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, createEmptyMap(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, createEmptyMap(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, createEmptyMap(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, createMap(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      var debug = options.consoleDebug;\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        var laststr = str;\n        if (debug) console.log('Working on: ', str);\n\n        for (var i = 0; i < rules.length; i++) {\n          var rulestr = '';\n\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n            if (debug) rulestr = rules[i].name;\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n\n            if (debug) {\n              rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n            }\n          }\n\n          if (debug) {\n            var newstr = res.toString({\n              parenthesis: 'all'\n            });\n\n            if (newstr !== laststr) {\n              console.log('Applying', rulestr, 'produced', newstr);\n              laststr = newstr;\n            }\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: 'v * (-c)'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: 'v * (-1)'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, simplifyConstant, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  }, // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  }, // All sub-monomials tried there.\n  {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, // remove parenthesis in the case of negating a quantity\n  // (It might seem this rule should precede collecting like terms,\n  // but putting it after gives another chance of noticing like terms,\n  // and any new like terms produced by this will be collected\n  // on the next pass through all the rules.)\n  {\n    l: 'n1 + (n2 + n3)*(-1)',\n    r: 'n1 + n2*(-1) + n3*(-1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // final ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.context = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  function mapRule(nodes, rule) {\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        nodes[i] = applyRule(nodes[i], rule);\n      }\n    }\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, applying the rule to it\n      // will have no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        mapRule(res.args, rule);\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } else if (res instanceof ArrayNode) {\n        mapRule(res.items, rule);\n      } else if (res instanceof AccessorNode) {\n        if (res.object) {\n          res.object = applyRule(res.object, rule);\n        }\n\n        if (res.index) {\n          res.index = applyRule(res.index, rule);\n        }\n      } else if (res instanceof IndexNode) {\n        mapRule(res.dimensions, rule);\n      } else if (res instanceof ObjectNode) {\n        for (var prop in res.properties) {\n          res.properties[prop] = applyRule(res.properties[prop], rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});","map":{"version":3,"names":["isConstantNode","isParenthesisNode","factory","createUtil","createSimplifyCore","createSimplifyConstant","createResolve","hasOwnProperty","createEmptyMap","createMap","name","dependencies","createSimplify","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","fraction","bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","simplifyConstant","simplifyCore","resolve","isCommutative","isAssociative","flatten","unflattenr","unflattenl","createMakeNodeFunction","simplify","string","expr","rules","stringMapObject","scope","stringMapObjectObject","options","stringArray","stringArrayMapObject","stringArrayMapObjectObject","NodeMapObject","NodeMapObjectObject","Node","NodeArray","NodeArrayMapObject","NodeArrayObjectObject","debug","consoleDebug","_buildRules","res","removeParens","visited","str","toString","parenthesis","_lastsym","laststr","console","log","i","length","rulestr","applyRule","concat","l","r","newstr","node","transform","path","parent","content","SUPPORTED_CONSTANTS","true","false","e","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","context","commutative","ruleSet","rule","newRule","ruleType","lr","split","SyntaxError","evaluate","makeNode","expandsym","_getExpandPlaceholderSymbol","expanded","clone","TypeError","push","mapRule","nodes","NodeObject","args","items","object","index","dimensions","prop","properties","repl","matches","_ruleMatch","implicit","isSymbolNode","placeholders","getSplits","right","rightArgs","slice","splice","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","s","JSON","stringify","isSplit","op","fn","childMatch","splits","splitMatches","_i","matchSet","Error","substring","value","p","q"],"sources":["C:/Users/Martin Simon/Desktop/programacion/portafolio/calculadora/node_modules/mathjs/lib/esm/function/algebra/simplify.js"],"sourcesContent":["import { isConstantNode, isParenthesisNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { createSimplifyCore } from './simplify/simplifyCore.js';\nimport { createSimplifyConstant } from './simplify/simplifyConstant.js';\nimport { createResolve } from './simplify/resolve.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    parse,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    isZero,\n    equal,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var simplifyConstant = createSimplifyConstant({\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  });\n  var simplifyCore = createSimplifyCore({\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode\n  });\n  var resolve = createResolve({\n    parse,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode\n  });\n  var {\n    isCommutative,\n    isAssociative,\n    flatten,\n    unflattenr,\n    unflattenl,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n        and any changes to it, along with the rule responsible, to console\n   *  - `exactFractions` (true): whether to try to convert all constants to\n        exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n        be expressed as fractions only when both numerator and denominator\n        are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, createEmptyMap(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, createEmptyMap(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, createEmptyMap(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, createEmptyMap(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, createMap(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      var debug = options.consoleDebug;\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        var laststr = str;\n        if (debug) console.log('Working on: ', str);\n\n        for (var i = 0; i < rules.length; i++) {\n          var rulestr = '';\n\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n            if (debug) rulestr = rules[i].name;\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n\n            if (debug) {\n              rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n            }\n          }\n\n          if (debug) {\n            var newstr = res.toString({\n              parenthesis: 'all'\n            });\n\n            if (newstr !== laststr) {\n              console.log('Applying', rulestr, 'produced', newstr);\n              laststr = newstr;\n            }\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: 'v * (-c)'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: 'v * (-1)'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, simplifyConstant, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  }, // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  }, // All sub-monomials tried there.\n  {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, // remove parenthesis in the case of negating a quantity\n  // (It might seem this rule should precede collecting like terms,\n  // but putting it after gives another chance of noticing like terms,\n  // and any new like terms produced by this will be collected\n  // on the next pass through all the rules.)\n  {\n    l: 'n1 + (n2 + n3)*(-1)',\n    r: 'n1 + n2*(-1) + n3*(-1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // final ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.context = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  function mapRule(nodes, rule) {\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        nodes[i] = applyRule(nodes[i], rule);\n      }\n    }\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, applying the rule to it\n      // will have no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        mapRule(res.args, rule);\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } else if (res instanceof ArrayNode) {\n        mapRule(res.items, rule);\n      } else if (res instanceof AccessorNode) {\n        if (res.object) {\n          res.object = applyRule(res.object, rule);\n        }\n\n        if (res.index) {\n          res.index = applyRule(res.index, rule);\n        }\n      } else if (res instanceof IndexNode) {\n        mapRule(res.dimensions, rule);\n      } else if (res instanceof ObjectNode) {\n        for (var prop in res.properties) {\n          res.properties[prop] = applyRule(res.properties[prop], rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}